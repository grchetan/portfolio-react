<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Canvas Cursor</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        min-height: 100vh;
        background: #f0f0f0; /* For visibility */
        overflow: hidden;
      }

      .cursor-trail {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100vh; /* h-screen */
        pointer-events: none; /* pointer-events-none */
        z-index: 50; /* z-50 */
      }
    </style>
  </head>
  <body>
    <canvas id="canvas" class="cursor-trail"></canvas>
    <script>
      const E = {
        debug: true,
        friction: 0.5,
        trails: 20,
        size: 50,
        dampening: 0.25,
        tension: 0.98,
      };

      let ctx = null;
      let f = null;
      let e = 0;
      let pos = { x: 0, y: 0 };
      let lines = [];

      function Oscillator(options = {}) {
        this.phase = options.phase || 0;
        this.offset = options.offset || 0;
        this.frequency = options.frequency || 0.001;
        this.amplitude = options.amplitude || 1;
      }

      Oscillator.prototype.update = function () {
        this.phase += this.frequency;
        e = this.offset + Math.sin(this.phase) * this.amplitude;
        return e;
      };

      Oscillator.prototype.value = function () {
        return e;
      };

      function Node() {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
      }

      function Line(options = {}) {
        this.spring = (options.spring || 0.45) + (0.1 * Math.random() - 0.02);
        this.friction = E.friction + (0.01 * Math.random() - 0.002);
        this.nodes = [];
        for (let i = 0; i < E.size; i++) {
          const node = new Node();
          node.x = pos.x;
          node.y = pos.y;
          this.nodes.push(node);
        }
      }

      Line.prototype.update = function () {
        let spring = this.spring;
        let node = this.nodes[0];

        node.vx += (pos.x - node.x) * spring;
        node.vy += (pos.y - node.y) * spring;

        for (let i = 0, len = this.nodes.length; i < len; i++) {
          node = this.nodes[i];

          if (i > 0) {
            const prev = this.nodes[i - 1];
            node.vx += (prev.x - node.x) * spring;
            node.vy += (prev.y - node.y) * spring;
            node.vx += prev.vx * E.dampening;
            node.vy += prev.vy * E.dampening;
          }

          node.vx *= this.friction;
          node.vy *= this.friction;
          node.x += node.vx;
          node.y += node.vy;

          spring *= E.tension;
        }
      };

      Line.prototype.draw = function () {
        if (!ctx) return;

        let x = this.nodes[0].x;
        let y = this.nodes[0].y;
        let curNode, nextNode;

        ctx.beginPath();
        ctx.moveTo(x, y);

        for (let i = 1, len = this.nodes.length - 2; i < len; i++) {
          curNode = this.nodes[i];
          nextNode = this.nodes[i + 1];
          x = 0.5 * (curNode.x + nextNode.x);
          y = 0.5 * (curNode.y + nextNode.y);
          ctx.quadraticCurveTo(curNode.x, curNode.y, x, y);
        }

        if (this.nodes.length > 2) {
          const i = this.nodes.length - 2;
          curNode = this.nodes[i];
          nextNode = this.nodes[i + 1];
          ctx.quadraticCurveTo(curNode.x, curNode.y, nextNode.x, nextNode.y);
        }

        ctx.stroke();
        ctx.closePath();
      };

      function createLines() {
        lines = [];
        for (let i = 0; i < E.trails; i++) {
          lines.push(new Line({ spring: 0.4 + (i / E.trails) * 0.025 }));
        }
      }

      function handlePointerMove(e) {
        if (e.touches && e.touches.length > 0) {
          pos.x = e.touches[0].pageX;
          pos.y = e.touches[0].pageY;
        } else {
          pos.x = e.clientX;
          pos.y = e.clientY;
        }

        if (e.cancelable) {
          e.preventDefault();
        }
      }

      function handleTouchStart(e) {
        if (e.touches.length === 1) {
          pos.x = e.touches[0].pageX;
          pos.y = e.touches[0].pageY;
        }
      }

      function render() {
        if (!ctx || ctx.running === false) return;

        ctx.globalCompositeOperation = "source-over";
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.globalCompositeOperation = "lighter";

        try {
          const hue = Math.round(f.update());
          ctx.strokeStyle = `hsla(${hue}, 50%, 50%, 0.2)`;
          ctx.lineWidth = 1;

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            line.update();
            line.draw();
          }

          ctx.frame++;
          window.requestAnimationFrame(render);
        } catch (error) {
          console.error("Error in render loop:", error);
          ctx.running = false;
        }
      }

      function resizeCanvas() {
        const canvas = document.getElementById("canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      function onMousemove(e) {
        document.removeEventListener("mousemove", onMousemove);
        document.removeEventListener("touchstart", onMousemove);

        document.addEventListener("mousemove", handlePointerMove);
        document.addEventListener("touchmove", handlePointerMove, {
          passive: true,
        });
        document.addEventListener("touchstart", handleTouchStart);

        handlePointerMove(e);
        createLines();
        render();
      }

      function initCanvas() {
        const canvas = document.getElementById("canvas");
        if (!canvas) return;

        ctx = canvas.getContext("2d");
        if (!ctx) return;

        ctx.running = true;
        ctx.frame = 1;

        f = new Oscillator({
          phase: Math.random() * 2 * Math.PI,
          amplitude: 85,
          frequency: 0.0015,
          offset: 285,
        });

        document.addEventListener("mousemove", onMousemove);
        document.addEventListener("touchstart", onMousemove);
        window.addEventListener("resize", resizeCanvas);

        window.addEventListener("focus", () => {
          if (ctx && ctx.running === false) {
            ctx.running = true;
            render();
          }
        });

        window.addEventListener("blur", () => {
          if (ctx) ctx.running = true; // Original sets to true, possibly a bug; consider setting to false
        });

        resizeCanvas();

        pos = {
          x: window.innerWidth / 2,
          y: window.innerHeight / 2,
        };

        createLines();
        render();
      }

      document.addEventListener("DOMContentLoaded", initCanvas);
    </script>
  </body>
</html>
